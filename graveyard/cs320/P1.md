---
title:  "P1"
layout: post
---
\>details here<

Python File:
{% highlight py %}

    import sys
    import math

    # BEGIN DO NOT MODIFY

    db = False
    swap_count = 0
    heapify_call_count = 0


    def reset_counts():
        global swap_count
        swap_count = 0
        global heapify_call_count
        heapify_call_count = 0

        
    def swap(A, i, j):
        global swap_count
        swap_count += 1
        A[i], A[j] = A[j], A[i]

        
    def count_heapify():
        global heapify_call_count
        heapify_call_count += 1


    def current_counts():
        return {'swap_count': swap_count, 'heapify_call_count': heapify_call_count}


    def readNums(filename):
        """Reads a text file containing whitespace separated numbers.
        Returns a list of those numbers."""
        with open(filename) as f:
            lst = [int(x) for line in f for x in line.strip().split() if x]
            if db:
                print("List read from file {}: {}".format(filename, lst))
            return lst

        
    # heaps here are complete binary trees allocated in arrays (0 based)
    def parent(i):
        return (i - 1) // 2


    def left(i):
        return 2 * i + 1


    def right(i):
        return left(i) + 1

    # END DO NOT MODIFY

    def heapify(A, i, n=None):
        """
        Most of the time heapify is called without the third parameter n. In those cases
        the heap occupies the full array, and therefore n=len(A). However in some circumstances
        (e.g. in heapSort see slide 36 in 02_bigO) heapify is called with smaller and smaller
        heaps occupying the left part of the array.
        

        Ensure that the tree rooted at element i in the list A is a min-heap,
        assuming that the trees rooted at elements left(i) and right(i) are already
        min-heaps. Obviously, if left(i) or right(i) are >= len(A), then element i simply does
        not have those out-of-bounds children. In order to implement an in-place heap sort,
        we will sometimes need to consider the tail part of A as out-of-bounds, even though
        elements do exist there. So instead of comparing with len(A), use the parameter n to
        determine if the child "exists" or not. If n is not provided, it defaults to None,
        which we check for and then set n to len(A).

        Since the (up to) two child trees are already min-heaps, we just need to find the right
        place for the element at i. If it is smaller than both its children, then nothing
        more needs to be done, it's already a min heap. Otherwise you should swap the root
        with the smallest child and recursively heapify that tree.

        If you determine that the element at i should swap with one of its children nodes,
        MAKE SURE you do this by calling the swap function defined above.
        """

        count_heapify() # This MUST be the first line of the heapify function, don't change it.
        if n is None:
            n = len(A)
        if not(i < n):
            # if asked to heapify an element not below n (the conceptual size of the heap), just return
            # because no work is required
            return
        # Your code here
        # Variables to hold left and right child values for readability
        l = left(i)
        r = right(i)
        min = i

        # if l < n and A[l] < A[i]:
        #     swap(A, i, l)
        #     heapify(A, l)
        # elif r < n and A[r] < A[i]:
        #     swap(A, i, r)
        #     heapify(A, r)

        # make sure we are less than the length and check for min swap
        if l < n and A[l] < A[i]:
            min = l
        if r < n and A[r] < A[min]:
            min = r
        # if i was bigger than a child swap
        if min != i:
            swap(A, i, min)
            heapify(A, min)
        


    def buildHeap(A):
        """Turn the list A (whose elements could be in any order) into a
        heap. Call heapify on all the internal nodes, starting with
        the last internal node, and working backwards to the root."""
        i = len(A)//2
        for i in range(i, -1, -1):
            heapify(A, i)
        


    def heapExtractMin(A):
        """Extract the min element from the heap A. Make sure that A
        is a valid heap afterwards. Return the extracted element.
        This operation should perform approximately log_2(len(A))
        comparisons and swaps (heapify calls and swap calls).
        Your implementation should not perform O(n) (linear) work."""
        min = A[0]
        A[0] = A[len(A) - 1]
        heapify(A, 0)
        return min



    def heapInsert(A, v):
        """Insert the element v into the heap A. Make sure that A
        is a valid heap afterwards.
        This operation should perform approximately log_2(len(A))
        comparisons and swaps (swap calls).
        Your implementation should not perform O(n) (linear) work.
        MAKE SURE you swap elements by calling the swap function defined above."""
        A.append(v)
        ind = len(A) - 1
        p = parent(ind)

        while p >= 0 and A[ind] < A[p]:
            swap(A, ind, p)
            ind = p
            p = parent(ind)

        



    def printCompleteTree(A):
        """ A handy function provided to you, so you can see a
        complete tree in its proper shape."""
        
        height = int(math.log(len(A), 2))
        width = len(str(max(A)))
        for i in range(height + 1):
            print(width * (2 ** (height - i) - 1) * " ", end="")
            for j in range(2 ** i):
                idx = 2 ** i - 1 + j
                if idx >= len(A):
                    print()
                    break
                if j == 2 ** i - 1:
                    print("{:^{width}}".format(A[idx], width=width))
                else:
                    print("{:^{width}}".format(A[idx], width=width),
                        width * (2 ** (height - i + 1) - 1) * " ", sep='', end='')
        print()


    def shuffled_list(length, seed):
        A = list(range(10, length + 10))
        import random
        r = random.Random(seed) # pseudo random, so it is repeatable
        r.shuffle(A)
        return A


    def report_counts_on_basic_ops(A, loop_extracts=1, loop_inserts=1):
        original_len = len(A)
        print("\nREPORT on list of len: {}".format(original_len))
        reset_counts()
        buildHeap(A)
        print("buildHeap(A):           \t", current_counts())

        reset_counts()
        m = heapExtractMin(A)
        print("heapExtractMin(A) => {}:\t".format(m), current_counts())

        reset_counts()
        heapInsert(A, m)
        print("heapInsert(A, {}):       \t".format(m), current_counts())

        for i in range(loop_extracts):
            reset_counts()
            m = heapExtractMin(A)
            print("heapExtractMin(A) => {}:\t".format(m), current_counts())

        import random
        r = random.Random(0)
        for i in range(loop_inserts):
            reset_counts()
            new_number = r.randrange(0, original_len // 8)
            heapInsert(A, new_number)
            print("heapInsert(A, {}):       \t".format(new_number), current_counts())


    def main():
        global db
        if len(sys.argv) > 2:
            db = True
        

        A = shuffled_list(20, 0)
        print("Complete Tree size 20:")
        printCompleteTree(A)
        buildHeap(A)
        print("Heap size 20:")
        printCompleteTree(A)


        A = shuffled_list(30, 0)
        report_counts_on_basic_ops(A)
        
        A = shuffled_list(400, 0)
        report_counts_on_basic_ops(A)
        
        A = shuffled_list(10000, 0)
        report_counts_on_basic_ops(A)

        A = shuffled_list(100000, 0)
        report_counts_on_basic_ops(A, 3, 3)

    if __name__ == "__main__":
        main()

{% endhighlight %}

Test Functionality File:
{% highlight py %}

    from argparse import ArgumentParser
    import heap


    def test_heapify():
        print("#test_heapify")
        A = [1]
        heap.heapify(A, 0)
        print("Heapify length 1:", A == [1])

        A = [2, 1]
        heap.heapify(A, 0)
        print("Heapify two out of order:", A == [1, 2])

        A = [1, 2]
        heap.heapify(A, 0)
        print("Heapify two in order:", A == [1, 2])

        A = [5, 4, 3, 2, 1]
        print("A: ",A)
        heap.heapify(A, 1)
        print("Heapify 1:", A == [5, 1, 3, 2, 4])

        A = [5, 1, 3, 2, 4]
        heap.heapify(A, 0)
        print("Heapify 0:", A == [1, 2, 3, 5, 4])


    def is_min_heap(A):
        def parent(i):
            return (i - 1) // 2
        return all(A[parent(x)] <= A[x] for x in range(1, len(A)))


    def shuffled_list(length, seed):
        A = list(range(10, length + 10))
        import random
        r = random.Random(seed) # pseudo random, so it is repeatable
        r.shuffle(A)
        return A


    def test_build_heap():
        print("#test_build_heap")
        for x in range(5, 41, 5):
            A = shuffled_list(x, x)
            heap.buildHeap(A)
            print("buildHeap(shuffled_list({}, {})) is a min heap: ".format(x, x), is_min_heap(A))


    def test_insert_extract():
        print("#test_insert_extract")
        for round in range(2):
            order = shuffled_list(30, round)
            A = []
            for x in range(10):
                heap.heapInsert(A, order.pop())
                heap.heapInsert(A, order.pop())
                has_heap_property = is_min_heap(A)
                min_elem = min(A)
                extracted = heap.heapExtractMin(A)
                print("Correctly extracted min: {}, maintained heap property: {}".format(
                    min_elem == extracted, has_heap_property and is_min_heap(A)))


    def is_sorted(A):
        for i in range(0, len(A)- 1):
            if not A[i] >= A[i+1]:
                return False
        return True



    def within_30_percent(expected, actual):
        margin = 0.3 * expected
        low = expected - margin
        hi = expected + margin
        return low <= actual <= hi

        
    def report_counts_on_basic_ops(A, expected_build_count, expected_extract_count, expected_insert_count):
        print("Counts for list of len: {}".format(len(A)))
        heap.reset_counts()
        heap.buildHeap(A)
        bh = heap.current_counts()['heapify_call_count']
        print("buildHeap heapify calls within 30% of expected number of calls: {}".format(within_30_percent(expected_build_count, bh)))

        heap.reset_counts()
        m = heap.heapExtractMin(A)
        ex = heap.current_counts()['heapify_call_count']
        print("heapExtractMin heapify calls within 30% of expected number of calls: {}".format(within_30_percent(expected_extract_count, ex)))

        heap.reset_counts()
        heap.heapInsert(A, m)
        ins = heap.current_counts()['swap_count']
        print("heapInsert swap calls within 30% of expected number of calls: {}".format(within_30_percent(expected_insert_count, ins)))


    def test_counts():
        print("#test_counts:")
        
        A = shuffled_list(400, 0)
        report_counts_on_basic_ops(A, 487, 8, 8)
        
        A = shuffled_list(10000, 0)
        report_counts_on_basic_ops(A, 12420, 14, 13)

        A = shuffled_list(100000, 0)
        report_counts_on_basic_ops(A, 124571, 17, 16)

                
    def test_all():
        test_heapify()
        test_build_heap()
        test_insert_extract()
        test_counts()


    def test_by_number(test_number):
        if test_number == 1:
            test_heapify()
        elif test_number == 2:
            test_build_heap()
        elif test_number == 3:
            test_insert_extract()
        else:
            test_counts()


    if __name__ == '__main__':
        parser = ArgumentParser()
        parser.add_argument("--test", dest="test_number",
                            type=int, help="The number of the test to run [1-4]")
        args = parser.parse_args()

        if args.test_number:
            test_by_number(args.test_number)
        else:
            test_all()

{% endhighlight %}